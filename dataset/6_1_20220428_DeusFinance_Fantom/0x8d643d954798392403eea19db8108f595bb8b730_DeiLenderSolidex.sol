{{
  "language": "Solidity",
  "sources": {
    "contracts/DeiLenderLP/DeiLenderSolidex.sol": {
      "content": "// Be name Khoda\r\n// Bime Abolfazl\r\n// SPDX-License-Identifier: GPL3.0-or-later\r\n\r\n// =================================================================================================================\r\n//  _|_|_|    _|_|_|_|  _|    _|    _|_|_|      _|_|_|_|  _|                                                       |\r\n//  _|    _|  _|        _|    _|  _|            _|            _|_|_|      _|_|_|  _|_|_|      _|_|_|    _|_|       |\r\n//  _|    _|  _|_|_|    _|    _|    _|_|        _|_|_|    _|  _|    _|  _|    _|  _|    _|  _|        _|_|_|_|     |\r\n//  _|    _|  _|        _|    _|        _|      _|        _|  _|    _|  _|    _|  _|    _|  _|        _|           |\r\n//  _|_|_|    _|_|_|_|    _|_|    _|_|_|        _|        _|  _|    _|    _|_|_|  _|    _|    _|_|_|    _|_|_|     |\r\n// =================================================================================================================\r\n// ==================== DEI Lender Solidex ===================\r\n// ==========================================================\r\n// DEUS Finance: https://github.com/deusfinance\r\n\r\n// Primary Author(s)\r\n// MRM: https://github.com/smrm-dev\r\n// MMD: https://github.com/mmd-mostafaee\r\n\r\n// Reviewer(s)\r\n// Vahid: https://github.com/vahid-dev\r\n// HHZ: https://github.com/hedzed\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"./interfaces/IMintHelper.sol\";\r\nimport \"./interfaces/IMuon.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport {SolidexHolder as Holder} from \"./SolidexHolder.sol\";\r\n\r\ninterface LpDepositor {\r\n    function getReward(address[] calldata pools) external;\r\n}\r\n\r\ninterface HIERC20 {\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\ninterface IOracle {\r\n    function getOnChainPrice() external view returns (uint256);\r\n\r\n    function getPrice(\r\n        uint256 price,\r\n        uint256 timestamp,\r\n        bytes calldata reqId,\r\n        SchnorrSign[] calldata sigs\r\n    ) external returns (uint256);\r\n}\r\n\r\ncontract DeiLenderSolidex is BoringOwnable {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using RebaseLibrary for Rebase;\r\n    using BoringERC20 for IERC20;\r\n\r\n    event UpdateAccrue(uint256 interest);\r\n    event Borrow(address from, address to, uint256 amount, uint256 debt);\r\n    event Repay(address from, address to, uint256 amount, uint256 repayAmount);\r\n    event AddCollateral(address from, address to, uint256 amount);\r\n    event RemoveCollateral(address from, address to, uint256 amount);\r\n    event Liquidate(\r\n        address liquidator,\r\n        address user,\r\n        uint256 collateralAmount,\r\n        uint256 deiAmount\r\n    );\r\n\r\n    IERC20 public collateral;\r\n\r\n    IERC20 public solid;\r\n    IERC20 public solidex;\r\n    address public lpDepositor;\r\n    uint256 public maxCap;\r\n\r\n    IOracle public oracle;\r\n\r\n    uint256 public BORROW_OPENING_FEE;\r\n\r\n    uint256 public LIQUIDATION_RATIO;\r\n\r\n    uint256 public totalCollateral;\r\n    Rebase public totalBorrow;\r\n\r\n    mapping(address => uint256) public userCollateral;\r\n    mapping(address => uint256) public userBorrow;\r\n    mapping(address => address) public userHolder;\r\n\r\n    address public mintHelper;\r\n\r\n    struct AccrueInfo {\r\n        uint256 lastAccrued;\r\n        uint256 feesEarned;\r\n        uint256 interestPerSecond;\r\n    }\r\n\r\n    AccrueInfo public accrueInfo;\r\n\r\n    constructor(\r\n        IERC20 collateral_,\r\n        IOracle oracle_,\r\n        IERC20 solid_,\r\n        IERC20 solidex_,\r\n        address lpDepositor_,\r\n        uint256 maxCap_,\r\n        uint256 interestPerSecond_,\r\n        uint256 borrowOpeningFee,\r\n        uint256 liquidationRatio,\r\n        address mintHelper_\r\n    ) public {\r\n        collateral = collateral_;\r\n        accrueInfo.interestPerSecond = interestPerSecond_;\r\n        accrueInfo.lastAccrued = block.timestamp;\r\n        BORROW_OPENING_FEE = borrowOpeningFee;\r\n        LIQUIDATION_RATIO = liquidationRatio;\r\n        oracle = oracle_;\r\n        solid = solid_;\r\n        solidex = solidex_;\r\n        lpDepositor = lpDepositor_;\r\n        maxCap = maxCap_;\r\n        mintHelper = mintHelper_;\r\n    }\r\n\r\n    function setUsersBorrowsAndCollaterals(\r\n        address[] memory users,\r\n        uint256[] memory borrowAmounts,\r\n        uint256[] memory collateralAmounts\r\n    ) public onlyOwner {\r\n        for (uint256 i = 0; i < users.length; i += 1) {\r\n            _setCollateral(users[i], collateralAmounts[i]);\r\n            _setBorrow(users[i], borrowAmounts[i]);\r\n        }\r\n    }\r\n\r\n    function _setCollateral(address to, uint256 amount) internal {\r\n        userCollateral[to] = amount;\r\n        totalCollateral = totalCollateral.add(amount);\r\n        if (userHolder[to] == address(0)) {\r\n            Holder holder = new Holder(address(lpDepositor), address(this), to);\r\n            userHolder[to] = address(holder);\r\n        }\r\n        collateral.safeTransferFrom(msg.sender, userHolder[to], amount);\r\n    }\r\n\r\n    function _setBorrow(address user, uint256 amount) internal {\r\n        totalBorrow = totalBorrow.add(amount, amount);\r\n        userBorrow[user] = amount;\r\n    }\r\n\r\n    function setOracle(IOracle oracle_) external onlyOwner {\r\n        oracle = oracle_;\r\n    }\r\n\r\n    function setMaxCap(uint256 maxCap_) external onlyOwner {\r\n        maxCap = maxCap_;\r\n    }\r\n\r\n    function setBorrowOpeningFee(uint256 borrowOpeningFee_) external onlyOwner {\r\n        BORROW_OPENING_FEE = borrowOpeningFee_;\r\n    }\r\n\r\n    function setLiquidationRatio(uint256 liquidationRatio_) external onlyOwner {\r\n        LIQUIDATION_RATIO = liquidationRatio_;\r\n    }\r\n\r\n    function setMintHelper(address mintHelper_) external onlyOwner {\r\n        mintHelper = mintHelper_;\r\n    }\r\n\r\n    function getRepayAmount(uint256 amount)\r\n        public\r\n        view\r\n        returns (uint256 repayAmount)\r\n    {\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        (uint128 elastic, ) = getCurrentElastic();\r\n        _totalBorrow.elastic = elastic;\r\n        (_totalBorrow, repayAmount) = _totalBorrow.sub(amount, true);\r\n    }\r\n\r\n    /// @notice returns user total debt (borrowed amount + interest)\r\n    function getDebt(address user) public view returns (uint256 debt) {\r\n        if (totalBorrow.base == 0) return 0;\r\n\r\n        (uint128 elastic, ) = getCurrentElastic();\r\n        return userBorrow[user].mul(uint256(elastic)) / totalBorrow.base;\r\n    }\r\n\r\n    /// @notice returns liquidation price for requested user\r\n    function getLiquidationPrice(address user) public view returns (uint256) {\r\n        uint256 userCollateralAmount = userCollateral[user];\r\n        if (userCollateralAmount == 0) return 0;\r\n\r\n        uint256 liquidationPrice = (getDebt(user).mul(1e18).mul(1e18)) /\r\n            (userCollateralAmount.mul(LIQUIDATION_RATIO));\r\n        return liquidationPrice;\r\n    }\r\n\r\n    /// @notice returns withdrawable amount for requested user\r\n    function getWithdrawableCollateralAmount(address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 userCollateralAmount = userCollateral[user];\r\n        if (userCollateralAmount == 0) return 0;\r\n\r\n        uint256 neededCollateral = (getDebt(user).mul(1e18).mul(1e18)) /\r\n            (oracle.getOnChainPrice().mul(LIQUIDATION_RATIO));\r\n\r\n        return\r\n            userCollateralAmount > neededCollateral\r\n                ? userCollateralAmount - neededCollateral\r\n                : 0;\r\n    }\r\n\r\n    function isSolvent(address user) external view returns (bool) {\r\n        uint256 userCollateralAmount = userCollateral[user];\r\n        if (userCollateralAmount == 0) return getDebt(user) == 0;\r\n\r\n        return\r\n            userCollateralAmount.mul(oracle.getOnChainPrice()).mul(\r\n                LIQUIDATION_RATIO\r\n            ) /\r\n                (uint256(1e18).mul(1e18)) >\r\n            getDebt(user);\r\n    }\r\n\r\n    function isSolvent(\r\n        address user,\r\n        uint256 price,\r\n        uint256 timestamp,\r\n        bytes calldata reqId,\r\n        SchnorrSign[] calldata sigs\r\n    ) internal returns (bool) {\r\n        // accrue must have already been called!\r\n\r\n        uint256 userCollateralAmount = userCollateral[user];\r\n        if (userCollateralAmount == 0) return getDebt(user) == 0;\r\n\r\n        return\r\n            userCollateralAmount\r\n                .mul(oracle.getPrice(price, timestamp, reqId, sigs))\r\n                .mul(LIQUIDATION_RATIO) /\r\n                (uint256(1e18).mul(1e18)) >\r\n            getDebt(user);\r\n    }\r\n\r\n    function getCurrentElastic()\r\n        internal\r\n        view\r\n        returns (uint128 elastic, uint128 interest)\r\n    {\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\r\n        if (elapsedTime != 0 && _totalBorrow.base != 0) {\r\n            interest = (uint256(_totalBorrow.elastic)\r\n                .mul(accrueInfo.interestPerSecond)\r\n                .mul(elapsedTime) / 1e18).to128();\r\n            elastic = _totalBorrow.elastic.add(interest);\r\n        } else {\r\n            return (totalBorrow.elastic, 0);\r\n        }\r\n    }\r\n\r\n    function accrue() public {\r\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\r\n        if (elapsedTime == 0) return;\r\n        if (totalBorrow.base == 0) {\r\n            accrueInfo.lastAccrued = uint256(block.timestamp);\r\n            return;\r\n        }\r\n\r\n        (uint128 elastic, uint128 interest) = getCurrentElastic();\r\n\r\n        accrueInfo.lastAccrued = uint256(block.timestamp);\r\n        totalBorrow.elastic = elastic;\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(interest);\r\n\r\n        emit UpdateAccrue(interest);\r\n    }\r\n\r\n    function addCollateral(address to, uint256 amount) public {\r\n        userCollateral[to] = userCollateral[to].add(amount);\r\n        totalCollateral = totalCollateral.add(amount);\r\n        if (userHolder[to] == address(0)) {\r\n            Holder holder = new Holder(lpDepositor, address(this), to);\r\n            userHolder[to] = address(holder);\r\n        }\r\n        collateral.safeTransferFrom(msg.sender, userHolder[to], amount);\r\n        emit AddCollateral(msg.sender, to, amount);\r\n    }\r\n\r\n    /// @param price collateral price (USD)\r\n    /// @param timestamp sign timestamp\r\n    function removeCollateral(\r\n        address to,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 timestamp,\r\n        bytes calldata reqId,\r\n        SchnorrSign[] calldata sigs\r\n    ) public {\r\n        accrue();\r\n        userCollateral[msg.sender] = userCollateral[msg.sender].sub(amount);\r\n\r\n        totalCollateral = totalCollateral.sub(amount);\r\n\r\n        Holder(userHolder[msg.sender]).withdrawERC20(\r\n            address(collateral),\r\n            to,\r\n            amount\r\n        );\r\n\r\n        require(\r\n            isSolvent(msg.sender, price, timestamp, reqId, sigs),\r\n            \"User is not solvent!\"\r\n        );\r\n        emit RemoveCollateral(msg.sender, to, amount);\r\n    }\r\n\r\n    function borrow(\r\n        address to,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 timestamp,\r\n        bytes calldata reqId,\r\n        SchnorrSign[] calldata sigs\r\n    ) public returns (uint256 debt) {\r\n        accrue();\r\n        uint256 fee = amount.mul(BORROW_OPENING_FEE) / 1e18;\r\n        (totalBorrow, debt) = totalBorrow.add(amount.add(fee), true);\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(fee);\r\n        userBorrow[msg.sender] = userBorrow[msg.sender].add(debt);\r\n\r\n        require(\r\n            totalBorrow.elastic <= maxCap,\r\n            \"Lender total borrow exceeds cap\"\r\n        );\r\n\r\n        require(\r\n            isSolvent(msg.sender, price, timestamp, reqId, sigs),\r\n            \"User is not solvent!\"\r\n        );\r\n\r\n        IMintHelper(mintHelper).mint(to, amount);\r\n\r\n        emit Borrow(msg.sender, to, amount.add(fee), debt);\r\n    }\r\n\r\n    function repayElastic(address to, uint256 debt)\r\n        public\r\n        returns (uint256 repayAmount)\r\n    {\r\n        accrue();\r\n\r\n        uint256 amount = debt.mul(totalBorrow.base) / totalBorrow.elastic;\r\n\r\n        (totalBorrow, repayAmount) = totalBorrow.sub(amount, true);\r\n        userBorrow[to] = userBorrow[to].sub(amount);\r\n\r\n        IMintHelper(mintHelper).burnFrom(msg.sender, repayAmount);\r\n\r\n        emit Repay(msg.sender, to, amount, repayAmount);\r\n    }\r\n\r\n    function repayBase(address to, uint256 amount)\r\n        public\r\n        returns (uint256 repayAmount)\r\n    {\r\n        accrue();\r\n\r\n        (totalBorrow, repayAmount) = totalBorrow.sub(amount, true);\r\n        userBorrow[to] = userBorrow[to].sub(amount);\r\n\r\n        IMintHelper(mintHelper).burnFrom(msg.sender, repayAmount);\r\n\r\n        emit Repay(msg.sender, to, amount, repayAmount);\r\n    }\r\n\r\n    function liquidate(\r\n        address[] calldata users,\r\n        address to,\r\n        uint256 price,\r\n        uint256 timestamp,\r\n        bytes calldata reqId,\r\n        SchnorrSign[] calldata sigs\r\n    ) public {\r\n        accrue();\r\n\r\n        uint256 totalCollateralAmount;\r\n        uint256 totalDeiAmount;\r\n\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n\r\n            if (!isSolvent(user, price, timestamp, reqId, sigs)) {\r\n                uint256 amount = userBorrow[user];\r\n\r\n                uint256 deiAmount;\r\n                (totalBorrow, deiAmount) = totalBorrow.sub(amount, true);\r\n\r\n                totalDeiAmount += deiAmount;\r\n                totalCollateralAmount += userCollateral[user];\r\n\r\n                emit RemoveCollateral(user, to, userCollateral[user]);\r\n                emit Repay(msg.sender, user, amount, deiAmount);\r\n                emit Liquidate(\r\n                    msg.sender,\r\n                    user,\r\n                    userCollateral[user],\r\n                    deiAmount\r\n                );\r\n\r\n                Holder(userHolder[user]).withdrawERC20(\r\n                    address(collateral),\r\n                    to,\r\n                    userCollateral[user]\r\n                );\r\n                userCollateral[user] = 0;\r\n                userBorrow[user] = 0;\r\n            }\r\n        }\r\n\r\n        require(totalDeiAmount != 0, \"All users are solvent\");\r\n\r\n        totalCollateral = totalCollateral.sub(totalCollateralAmount);\r\n\r\n        IMintHelper(mintHelper).burnFrom(msg.sender, totalDeiAmount);\r\n    }\r\n\r\n    function withdrawFees(address to, uint256 amount) public onlyOwner {\r\n        accrue();\r\n\r\n        IMintHelper(mintHelper).mint(to, amount);\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.sub(amount);\r\n    }\r\n\r\n    function claim(address[] calldata pools) public {\r\n        Holder(userHolder[msg.sender]).claim(pools);\r\n    }\r\n\r\n    function claimAndWithdraw(address[] calldata pools, address to) public {\r\n        Holder(userHolder[msg.sender]).claim(pools);\r\n        Holder(userHolder[msg.sender]).withdrawERC20(\r\n            address(solid),\r\n            to,\r\n            solid.balanceOf(userHolder[msg.sender])\r\n        );\r\n        Holder(userHolder[msg.sender]).withdrawERC20(\r\n            address(solidex),\r\n            to,\r\n            solidex.balanceOf(userHolder[msg.sender])\r\n        );\r\n    }\r\n\r\n    function emergencyHolderWithdraw(\r\n        address holder,\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        Holder(holder).withdrawERC20(token, to, amount);\r\n    }\r\n\r\n    function emergencyWithdraw(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        HIERC20(token).transfer(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/DeiLenderLP/interfaces/IMintHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL3.0-or-later\r\n\r\ninterface IMintHelper {\r\n    function dei() external view returns (address);\r\n\r\n    function useVirtualReserve(address pool) external view returns (bool);\r\n\r\n    function virtualReserve() external view returns (uint256);\r\n\r\n    function MINTER_ROLE() external view returns (bytes32);\r\n\r\n    function mint(address recv, uint256 amount) external;\r\n\r\n    function burnFrom(address from, uint256 amount) external;\r\n\r\n    function collatDollarBalance(uint256 collat_usd_price)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function setVirtualReserve(uint256 virtualReserve_) external;\r\n\r\n    function setUseVirtualReserve(address pool, bool state) external;\r\n}\r\n"
    },
    "contracts/DeiLenderLP/interfaces/IMuon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nstruct SchnorrSign {\r\n    uint256 signature;\r\n    address owner;\r\n    address nonce;\r\n}\r\n\r\ninterface IMuonV02 {\r\n    function verify(\r\n        bytes calldata reqId,\r\n        uint256 hash,\r\n        SchnorrSign[] calldata _sigs\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) private {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n    }\n\n    function _burn(address user, uint256 amount) private {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = elastic.mul(total.base) / total.elastic;\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n                base = base.add(1);\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = base.mul(total.elastic) / total.base;\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n                elastic = elastic.add(1);\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while(i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "contracts/DeiLenderLP/SolidexHolder.sol": {
      "content": "// Be name Khoda\r\n// Bime Abolfazl\r\n// SPDX-License-Identifier: MIT\r\n\r\n// =================================================================================================================\r\n//  _|_|_|    _|_|_|_|  _|    _|    _|_|_|      _|_|_|_|  _|                                                       |\r\n//  _|    _|  _|        _|    _|  _|            _|            _|_|_|      _|_|_|  _|_|_|      _|_|_|    _|_|       |\r\n//  _|    _|  _|_|_|    _|    _|    _|_|        _|_|_|    _|  _|    _|  _|    _|  _|    _|  _|        _|_|_|_|     |\r\n//  _|    _|  _|        _|    _|        _|      _|        _|  _|    _|  _|    _|  _|    _|  _|        _|           |\r\n//  _|_|_|    _|_|_|_|    _|_|    _|_|_|        _|        _|  _|    _|    _|_|_|  _|    _|    _|_|_|    _|_|_|     |\r\n// =================================================================================================================\r\n// ==================== Holder ===================\r\n// ==============================================\r\n// DEUS Finance: https://github.com/deusfinance\r\n\r\n// Primary Author(s)\r\n// Mmd: https://github.com/mmd-mostafaee\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface LpDepositor {\r\n    function getReward(address[] calldata pools) external;\r\n}\r\n\r\ninterface HIERC20 {\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\ncontract SolidexHolder {\r\n    LpDepositor public lpDepositor;\r\n    address public lender;\r\n    address public user;\r\n\r\n    constructor(\r\n        address lpDepositor_,\r\n        address lender_,\r\n        address user_\r\n    ) public {\r\n        lpDepositor = LpDepositor(lpDepositor_);\r\n        lender = lender_;\r\n        user = user_;\r\n    }\r\n\r\n    function claim(address[] calldata pools) public {\r\n        lpDepositor.getReward(pools);\r\n    }\r\n\r\n    function withdrawERC20(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(msg.sender == lender, \"SolidexHolder: You are not lender\");\r\n        HIERC20(token).transfer(to, amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n//Dar panah khoda\r\n"
    },
    "@boringcrypto/boring-solidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity 0.6.12;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;    \n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_SEPARATOR_SIGNATURE_HASH,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    constructor() public {\n        uint256 chainId; assembly {chainId := chainid()}\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId; assembly {chainId := chainid()}\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest =\n            keccak256(\n                abi.encodePacked(\n                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                    _domainSeparator(),\n                    dataHash\n                )\n            );\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}