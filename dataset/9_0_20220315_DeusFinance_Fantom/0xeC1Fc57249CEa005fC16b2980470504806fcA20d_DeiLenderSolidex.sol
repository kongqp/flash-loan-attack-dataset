{{
  "language": "Solidity",
  "sources": {
    "contracts/DeiLenderLP/DeiLenderSolidex.sol": {
      "content": "// Be name Khoda\n// Bime Abolfazl\n// SPDX-License-Identifier: GPL3.0-or-later\n\n// =================================================================================================================\n//  _|_|_|    _|_|_|_|  _|    _|    _|_|_|      _|_|_|_|  _|                                                       |\n//  _|    _|  _|        _|    _|  _|            _|            _|_|_|      _|_|_|  _|_|_|      _|_|_|    _|_|       |\n//  _|    _|  _|_|_|    _|    _|    _|_|        _|_|_|    _|  _|    _|  _|    _|  _|    _|  _|        _|_|_|_|     |\n//  _|    _|  _|        _|    _|        _|      _|        _|  _|    _|  _|    _|  _|    _|  _|        _|           |\n//  _|_|_|    _|_|_|_|    _|_|    _|_|_|        _|        _|  _|    _|    _|_|_|  _|    _|    _|_|_|    _|_|_|     |\n// =================================================================================================================\n// ==================== DEI Lender Solidex ===================\n// ==========================================================\n// DEUS Finance: https://github.com/deusfinance\n\n// Primary Author(s)\n// MRM: https://github.com/smrm-dev\n// MMD: https://github.com/mmd-mostafaee\n\n// Reviewer(s)\n// Vahid: https://github.com/vahid-dev\n// HHZ: https://github.com/hedzed\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IMintHelper.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SolidexHolder as Holder} from \"./SolidexHolder.sol\";\n\ninterface LpDepositor {\n    function getReward(address[] calldata pools) external;\n}\n\ninterface HIERC20 {\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IOracle {\n    function getPrice() external view returns (uint256);\n}\n\ncontract DeiLenderSolidex is BoringOwnable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event UpdateAccrue(uint256 interest);\n    event Borrow(address from, address to, uint256 amount, uint256 debt);\n    event Repay(address from, address to, uint256 amount, uint256 repayAmount);\n    event AddCollateral(address from, address to, uint256 amount);\n    event RemoveCollateral(address from, address to, uint256 amount);\n\n    IERC20 public collateral;\n\n    IERC20 public solid;\n    IERC20 public solidex;\n    address public lpDepositor;\n    uint256 public maxCap;\n\n    IOracle public oracle;\n\n    uint256 public BORROW_OPENING_FEE;\n\n    uint256 public LIQUIDATION_RATIO;\n\n    uint256 public totalCollateral;\n    Rebase public totalBorrow;\n\n    mapping(address => uint256) public userCollateral;\n    mapping(address => uint256) public userBorrow;\n    mapping(address => address) public userHolder;\n\n    address public mintHelper;\n\n    struct AccrueInfo {\n        uint256 lastAccrued;\n        uint256 feesEarned;\n        uint256 interestPerSecond;\n    }\n\n    AccrueInfo public accrueInfo;\n\n    constructor(\n        IERC20 collateral_,\n        IOracle oracle_,\n        IERC20 solid_,\n        IERC20 solidex_,\n        address lpDepositor_,\n        uint256 maxCap_,\n        uint256 interestPerSecond_,\n        uint256 borrowOpeningFee,\n        uint256 liquidationRatio,\n        address mintHelper_\n    ) public {\n        collateral = collateral_;\n        accrueInfo.interestPerSecond = interestPerSecond_;\n        accrueInfo.lastAccrued = block.timestamp;\n        BORROW_OPENING_FEE = borrowOpeningFee;\n        LIQUIDATION_RATIO = liquidationRatio;\n        oracle = oracle_;\n        solid = solid_;\n        solidex = solidex_;\n        lpDepositor = lpDepositor_;\n        maxCap = maxCap_;\n        mintHelper = mintHelper_;\n    }\n\n    function setOracle(IOracle oracle_) external onlyOwner {\n        oracle = oracle_;\n    }\n\n    function setMaxCap(uint256 maxCap_) external onlyOwner {\n        maxCap = maxCap_;\n    }\n\n    function setBorrowOpeningFee(uint256 borrowOpeningFee_) external onlyOwner {\n        BORROW_OPENING_FEE = borrowOpeningFee_;\n    }\n\n    function setLiquidationRatio(uint256 liquidationRatio_) external onlyOwner {\n        LIQUIDATION_RATIO = liquidationRatio_;\n    }\n\n    function setMintHelper(address mintHelper_) external onlyOwner {\n        mintHelper = mintHelper_;\n    }\n\n    function getRepayAmount(uint256 amount)\n        public\n        view\n        returns (uint256 repayAmount)\n    {\n        Rebase memory _totalBorrow = totalBorrow;\n        (uint128 elastic, ) = getCurrentElastic();\n        _totalBorrow.elastic = elastic;\n        (_totalBorrow, repayAmount) = _totalBorrow.sub(amount, true);\n    }\n\n    /// returns user total debt (borrowed amount + interest)\n    function getDebt(address user) public view returns (uint256 debt) {\n        if (totalBorrow.base == 0) return 0;\n\n        (uint128 elastic, ) = getCurrentElastic();\n        return userBorrow[user].mul(uint256(elastic)) / totalBorrow.base;\n    }\n\n    /// returns liquidation price for requested user\n    function getLiquidationPrice(address user) public view returns (uint256) {\n        uint256 userCollateralAmount = userCollateral[user];\n        if (userCollateralAmount == 0) return 0;\n\n        uint256 liquidationPrice = (getDebt(user).mul(1e18).mul(1e18)) /\n            (userCollateralAmount.mul(LIQUIDATION_RATIO));\n        return liquidationPrice;\n    }\n\n    /// returns withdrawable amount for requested user\n    function getWithdrawableCollateralAmount(address user)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 userCollateralAmount = userCollateral[user];\n        if (userCollateralAmount == 0) return 0;\n\n        uint256 neededCollateral = (getDebt(user).mul(1e18).mul(1e18)) /\n            (oracle.getPrice().mul(LIQUIDATION_RATIO));\n\n        return\n            userCollateralAmount > neededCollateral\n                ? userCollateralAmount - neededCollateral\n                : 0;\n    }\n\n    function isSolvent(address user) public view returns (bool) {\n        // accrue must have already been called!\n\n        uint256 userCollateralAmount = userCollateral[user];\n        if (userCollateralAmount == 0) return getDebt(user) == 0;\n\n        return\n            userCollateralAmount.mul(oracle.getPrice()).mul(LIQUIDATION_RATIO) /\n                (uint256(1e18).mul(1e18)) >\n            getDebt(user);\n    }\n\n    function getCurrentElastic()\n        internal\n        view\n        returns (uint128 elastic, uint128 interest)\n    {\n        Rebase memory _totalBorrow = totalBorrow;\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\n        if (elapsedTime != 0 && _totalBorrow.base != 0) {\n            interest = (uint256(_totalBorrow.elastic)\n                .mul(accrueInfo.interestPerSecond)\n                .mul(elapsedTime) / 1e18).to128();\n            elastic = _totalBorrow.elastic.add(interest);\n        } else {\n            return (totalBorrow.elastic, 0);\n        }\n    }\n\n    function accrue() public {\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\n        if (elapsedTime == 0) return;\n        if (totalBorrow.base == 0) {\n            accrueInfo.lastAccrued = uint256(block.timestamp);\n            return;\n        }\n\n        (uint128 elastic, uint128 interest) = getCurrentElastic();\n\n        accrueInfo.lastAccrued = uint256(block.timestamp);\n        totalBorrow.elastic = elastic;\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(interest);\n\n        emit UpdateAccrue(interest);\n    }\n\n    function addCollateral(address to, uint256 amount) public {\n        userCollateral[to] = userCollateral[to].add(amount);\n        totalCollateral = totalCollateral.add(amount);\n        if (userHolder[to] == address(0)) {\n            Holder holder = new Holder(lpDepositor, address(this), to);\n            userHolder[to] = address(holder);\n        }\n        collateral.safeTransferFrom(msg.sender, userHolder[to], amount);\n        emit AddCollateral(msg.sender, to, amount);\n    }\n\n    function removeCollateral(address to, uint256 amount) public {\n        accrue();\n        userCollateral[msg.sender] = userCollateral[msg.sender].sub(amount);\n\n        totalCollateral = totalCollateral.sub(amount);\n\n        Holder(userHolder[msg.sender]).withdrawERC20(\n            address(collateral),\n            to,\n            amount\n        );\n\n        require(isSolvent(msg.sender), \"User is not solvent!\");\n        emit RemoveCollateral(msg.sender, to, amount);\n    }\n\n    function borrow(address to, uint256 amount) public returns (uint256 debt) {\n        accrue();\n        uint256 fee = amount.mul(BORROW_OPENING_FEE) / 1e18;\n        (totalBorrow, debt) = totalBorrow.add(amount.add(fee), true);\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(fee);\n        userBorrow[msg.sender] = userBorrow[msg.sender].add(debt);\n\n        require(\n            totalBorrow.elastic <= maxCap,\n            \"Lender total borrow exceeds cap\"\n        );\n        require(isSolvent(msg.sender), \"User is not solvent!\");\n        IMintHelper(mintHelper).mint(to, amount);\n        emit Borrow(msg.sender, to, amount.add(fee), debt);\n    }\n\n    function repayElastic(address to, uint256 debt)\n        public\n        returns (uint256 repayAmount)\n    {\n        accrue();\n\n        uint256 amount = debt.mul(totalBorrow.base) / totalBorrow.elastic;\n\n        (totalBorrow, repayAmount) = totalBorrow.sub(amount, true);\n        userBorrow[to] = userBorrow[to].sub(amount);\n\n        IMintHelper(mintHelper).burnFrom(msg.sender, repayAmount);\n\n        emit Repay(msg.sender, to, amount, repayAmount);\n    }\n\n    function repayBase(address to, uint256 amount)\n        public\n        returns (uint256 repayAmount)\n    {\n        accrue();\n\n        (totalBorrow, repayAmount) = totalBorrow.sub(amount, true);\n        userBorrow[to] = userBorrow[to].sub(amount);\n\n        IMintHelper(mintHelper).burnFrom(msg.sender, repayAmount);\n\n        emit Repay(msg.sender, to, amount, repayAmount);\n    }\n\n    function liquidate(address[] calldata users, address to) public {\n        accrue();\n\n        uint256 totalCollateralAmount;\n        uint256 totalDeiAmount;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n\n            if (!isSolvent(user)) {\n                uint256 amount = userBorrow[user];\n\n                uint256 deiAmount;\n                (totalBorrow, deiAmount) = totalBorrow.sub(amount, true);\n\n                totalDeiAmount += deiAmount;\n                totalCollateralAmount += userCollateral[user];\n\n                emit RemoveCollateral(user, to, userCollateral[user]);\n                emit Repay(msg.sender, user, amount, deiAmount);\n\n                Holder(userHolder[user]).withdrawERC20(\n                    address(collateral),\n                    to,\n                    userCollateral[user]\n                );\n                userCollateral[user] = 0;\n                userBorrow[user] = 0;\n            }\n        }\n\n        require(totalDeiAmount != 0, \"All users are solvent\");\n\n        IMintHelper(mintHelper).burnFrom(msg.sender, totalDeiAmount);\n    }\n\n    function withdrawFees(address to, uint256 amount) public onlyOwner {\n        accrue();\n\n        IMintHelper(mintHelper).mint(to, amount);\n        accrueInfo.feesEarned = accrueInfo.feesEarned.sub(amount);\n    }\n\n    function claim(address[] calldata pools) public {\n        Holder(userHolder[msg.sender]).claim(pools);\n    }\n\n    function claimAndWithdraw(address[] calldata pools, address to) public {\n        Holder(userHolder[msg.sender]).claim(pools);\n        Holder(userHolder[msg.sender]).withdrawERC20(\n            address(solid),\n            to,\n            solid.balanceOf(userHolder[msg.sender])\n        );\n        Holder(userHolder[msg.sender]).withdrawERC20(\n            address(solidex),\n            to,\n            solidex.balanceOf(userHolder[msg.sender])\n        );\n    }\n\n    function emergencyHolderWithdraw(\n        address holder,\n        address token,\n        address to,\n        uint256 amount\n    ) public onlyOwner {\n        Holder(holder).withdrawERC20(token, to, amount);\n    }\n\n    function emergencyWithdraw(\n        address token,\n        address to,\n        uint256 amount\n    ) public onlyOwner {\n        HIERC20(token).transfer(to, amount);\n    }\n}\n"
    },
    "contracts/DeiLenderLP/interfaces/IMintHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL3.0-or-later\n\ninterface IMintHelper {\n    function dei() external view returns (address);\n\n    function useVirtualReserve(address pool) external view returns (bool);\n\n    function virtualReserve() external view returns (uint256);\n\n    function MINTER_ROLE() external view returns (bytes32);\n\n    function mint(address recv, uint256 amount) external;\n\n    function burnFrom(address from, uint256 amount) external;\n\n    function collatDollarBalance(uint256 collat_usd_price)\n        external\n        view\n        returns (uint256);\n\n    function setVirtualReserve(uint256 virtualReserve_) external;\n\n    function setUseVirtualReserve(address pool, bool state) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) private {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n    }\n\n    function _burn(address user, uint256 amount) private {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = elastic.mul(total.base) / total.elastic;\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n                base = base.add(1);\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = base.mul(total.elastic) / total.base;\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n                elastic = elastic.add(1);\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while(i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "contracts/DeiLenderLP/SolidexHolder.sol": {
      "content": "// Be name Khoda\n// Bime Abolfazl\n// SPDX-License-Identifier: MIT\n\n// =================================================================================================================\n//  _|_|_|    _|_|_|_|  _|    _|    _|_|_|      _|_|_|_|  _|                                                       |\n//  _|    _|  _|        _|    _|  _|            _|            _|_|_|      _|_|_|  _|_|_|      _|_|_|    _|_|       |\n//  _|    _|  _|_|_|    _|    _|    _|_|        _|_|_|    _|  _|    _|  _|    _|  _|    _|  _|        _|_|_|_|     |\n//  _|    _|  _|        _|    _|        _|      _|        _|  _|    _|  _|    _|  _|    _|  _|        _|           |\n//  _|_|_|    _|_|_|_|    _|_|    _|_|_|        _|        _|  _|    _|    _|_|_|  _|    _|    _|_|_|    _|_|_|     |\n// =================================================================================================================\n// ==================== Holder ===================\n// ==============================================\n// DEUS Finance: https://github.com/deusfinance\n\n// Primary Author(s)\n// Mmd: https://github.com/mmd-motafaee\n\npragma solidity 0.6.12;\n\ninterface LpDepositor {\n    function getReward(address[] calldata pools) external;\n}\n\ninterface HIERC20 {\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ncontract SolidexHolder {\n    LpDepositor public lpDepositor;\n    address public lender;\n    address public user;\n\n    constructor(\n        address lpDepositor_,\n        address lender_,\n        address user_\n    ) public {\n        lpDepositor = LpDepositor(lpDepositor_);\n        lender = lender_;\n        user = user_;\n    }\n\n    function claim(address[] calldata pools) public {\n        lpDepositor.getReward(pools);\n    }\n\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(msg.sender == lender, \"SolidexHolder: You are not lender\");\n        HIERC20(token).transfer(to, amount);\n        return true;\n    }\n}\n\n//Dar panah khoda\n"
    },
    "@boringcrypto/boring-solidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity 0.6.12;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;    \n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_SEPARATOR_SIGNATURE_HASH,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    constructor() public {\n        uint256 chainId; assembly {chainId := chainid()}\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId; assembly {chainId := chainid()}\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest =\n            keccak256(\n                abi.encodePacked(\n                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                    _domainSeparator(),\n                    dataHash\n                )\n            );\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}